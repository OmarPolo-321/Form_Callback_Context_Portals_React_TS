ðŸ§  Â¿QuÃ© es useCallback?
Es un hook de React que te permite memorizar funciones para que no se vuelvan a crear en cada render, a menos que cambien sus dependencias.

    const memoizedCallback = useCallback(() => {
    // tu funciÃ³n
    }, [dependencias]);

    - âš ï¸ No se ejecuta como useEffect. Solo memoriza la funciÃ³n.
    - âœ… Mantiene la misma referencia en cada render.

ðŸ“¦ Â¿Para quÃ© sirve realmente?
ðŸ” En cada render, React recrea todas las funciones definidas dentro del componente.

Eso puede causar:

    - âš ï¸ Re-render innecesario de componentes hijos
    - âŒ Ineficiencia en listas, tablas o efectos

useCallback evita eso, manteniendo la misma referencia de funciÃ³n entre renders, a menos que sus dependencias cambien.

ðŸ§  Â¿QuÃ© hace useCallback internamente?

    - Memoriza una funciÃ³n
    - Solo la vuelve a generar si cambian las dependencias
    - Ayuda a evitar renders innecesarios cuando se pasan funciones como props

âœ… Â¿CuÃ¡ndo se debe usar useCallback?
                                  
Casos reales -> ðŸ” Pasas funciones a componentes hijos memoizados (React.memo)	
        ExplicaciÃ³n -> Evitas que el hijo se re-renderice
Casos reales -> ðŸ§® En listas, grids, renders complejos	
        ExplicaciÃ³n -> Para optimizar el rendimiento
Casos reales -> ðŸ§  Al usar dependencias dentro de useEffect, useMemo, etc.	
        ExplicaciÃ³n ->Para evitar loops o renders infinitos

ðŸš¨ Â¡Pero cuidado!
    - Si tu componente no se renderiza muchas veces â†’ No necesitas useCallback.
    - Solo Ãºsalo cuando pase funciones como props o haya rendimiento crÃ­tico.

ðŸ“˜ Ejemplo 1: Sin useCallback (mal rendimiento)
const Parent = () => {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    console.log("clicked");
  };

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Sumar</button>
      <Child onClick={handleClick} />
    </>
  );
};

const Child = React.memo(({ onClick }: { onClick: () => void }) => {
  console.log("Child render");
  return <button onClick={onClick}>Click</button>;
});
ðŸ”´ Aunque Child estÃ¡ memoizado, se renderiza siempre porque handleClick 
cambia en cada render (nueva funciÃ³n).

âœ… Ejemplo 2: Con useCallback (solucionado)

const handleClick = useCallback(() => {
  console.log("clicked");
}, []); // no depende de nada

// Ahora no se recrea en cada render

    - âœ… Child no se re-renderiza innecesariamente. 
    - âœ… FunciÃ³n con referencia estable.

ðŸ“˜ Ejemplo 3: Dependencias dinÃ¡micas

const [name, setName] = useState("Omar");

const greet = useCallback(() => {
  console.log(`Hola ${name}`);
}, [name]); // Solo cambia si `name` cambia


âš™ï¸ Ejemplo real profesional: Lista de tareas

const TodoItem = React.memo(({ onToggle }: { onToggle: () => void }) => {
  console.log("TodoItem render");
  return <input type="checkbox" onChange={onToggle} />;
});

const TodoList = () => {
  const [completed, setCompleted] = useState(false);

  const toggle = useCallback(() => {
    setCompleted((prev) => !prev);
  }, []);

  return <TodoItem onToggle={toggle} />;
};

    âœ… useCallback evita que la funciÃ³n toggle cambie en cada render 
        y mantiene la eficiencia del componente memoizado.



ðŸ§  Â¿CuÃ¡l es la diferencia entre useCallback y useMemo?
useCallback -> Memoriza funciones
useMemo -> Memoriza valores devueltos por funciones